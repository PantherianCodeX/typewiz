# ADR-0004: Repository Taxonomy and Directory Structure

* **Status:** Accepted
* **Date:** 2025-12-15
* **Deciders:** Ratchetr maintainers
* **Technical Story:** N/A (foundational repository taxonomy for pre-release)

## Context and Problem Statement

Ratchetr’s codebase already spans multiple concerns: CLI presentation, configuration ingestion, engine execution, artifact construction (manifest/dashboards), persistence orchestration, and supporting infrastructure. In ratchetr-0.1.0-dev-3, the repository contains the core package under `src/ratchetr/`, supporting assets (`schemas/`, `typings/`, `scripts/`, `docs/`, `examples/`), and a multi-suite test pyramid (`tests/`).

Without a precise, enforceable taxonomy, structure drift becomes likely:

* “Convenience” placement of logic in inappropriate layers (especially shims/helpers).
* Dependency cycles between CLI, services, and feature packages.
* A “shared utils” grab-bag replacing deliberate modularity.
* Tests that no longer mirror product boundaries, making coverage placement arbitrary.
* Generated artifacts and build outputs being committed into source trees.

This ADR defines **taxonomy and directory structure only**: package roles, layering rules, allowed dependency directions, and test layout. Behavioral policy (CLI semantics, precedence, scoping, planning) is explicitly out of scope.

## Decision Drivers

* **Layer separation:** clear ownership boundaries and one-way dependencies.
* **Cycle avoidance:** prevent CLI ↔ feature coupling and similar structural hazards.
* **Curated sharing:** allow DRY refactors without creating a “misc utils” dumping ground.
* **Repo hygiene:** keep generated artifacts and build outputs out of `src/` and out of VCS.
* **Test discoverability:** tests should mirror product domains and suite intent.

## Considered Options

1. **Ad hoc placement** (feature-local by default, occasional shared helpers wherever convenient).
2. **Central “shared utils/common” hub** for cross-cutting code.
3. **Layered taxonomy with curated shared package(s) and explicit boundary packages** (chosen).

## Decision Outcome

### Chosen Option

Adopt a **layered repository taxonomy** with explicit directory roles, constrained dependency directions, and a curated cross-feature sharing strategy.

### High-level structure

#### Repository tree (dev-3 observed)

```text
.
├── src/
│   ├── ratchetr/                 # product package (runtime)
│   └── ratchetr.egg-info/        # build artifact (noncompliant to keep)
├── tests/                        # test pyramid suites
├── schemas/                      # JSON Schema contracts
├── typings/                      # third-party typing stubs
├── scripts/                      # developer tooling (non-runtime)
├── docs/                         # documentation + ADRs
├── examples/                      # example projects/configs
└── .github/                      # CI workflows
```

#### Layering diagram (dependency direction)

```text
cli/  ───────────────▶  services/  ───────────────▶  feature packages
                                          │
                                          ▼
                                  core/ + compat/
```

Private infrastructure supports multiple layers but must remain dependency-safe:

```text
_internal/ + _internal/utils/  (private infrastructure; no CLI dependency)
```

Curated sharing exists only to avoid cycles when two layers need the same helper:

```text
common/  (small, curated, cross-feature; avoid “utils hub”)
```

### Taxonomy rules for `src/ratchetr/`

#### 1) Package root modules (`src/ratchetr/*.py`)

**Role:** stable public surface and limited cross-cutting utilities.

**Allowed:**

* **Thin shims** over private implementations (re-export/forwarding).
* Minimal entry points (`__main__.py`) and public façade modules (`api.py`) that delegate to `services/`.
* Small dependency-safe primitives that do not encode feature semantics.

**Prohibited:**

* Feature/business logic.
* CLI-specific logic.
* Boundary translation for external schemas/payloads.

**Why:** root modules are the most “reachable” imports; keeping them thin prevents unintentional coupling and cycle creation.

#### 2) `cli/` (presentation layer)

**Role:** argument parsing, user-facing formatting, exit codes, and command dispatch.

**Allowed:**

* CLI command modules (`cli/commands/*`).
* CLI-only helpers (`cli/helpers/*`) that **delegate** to config/path/services APIs and avoid embedding business rules.

**Prohibited:**

* Domain logic for auditing/ratcheting/manifest semantics.
* Persistence orchestration.
* Engine execution logic.

#### 3) `services/` (orchestration layer)

**Role:** application orchestration and side-effect boundaries (file I/O coordination, persistence gating).

**Allowed:**

* Coordinating multiple feature modules into cohesive operations.
* Owning “where side effects happen” (persistence, output emission coordination).

**Prohibited:**

* CLI parsing/presentation.
* Re-defining feature semantics already owned by feature packages.

#### 4) Feature packages (domain logic)

Observed feature packages in dev-3:

* `audit/`, `dashboard/`, `manifest/`, `ratchet/`, `readiness/`
* `engines/` (engine interface, registry, builtin engines)

**Role:** domain logic and feature-owned structures.

**Allowed:**

* Feature-local runtime code.
* Feature-owned typed schemas and validation models (where applicable).

**Prohibited:**

* CLI concerns.
* Cross-feature “general utilities” unless promoted via the curated sharing rule (below).

#### 5) `core/` (shared vocabulary)

**Role:** cross-feature types and shared primitives that are stable and broadly reused.

**Constraints:**

* Keep `core/` dependency-light.
* Avoid moving feature-owned concepts into `core/` merely for convenience.

#### 6) `compat/` (compatibility layer)

**Role:** cross-version/platform compatibility shims.

**Constraints:**

* Must remain dependency-leaf-like (no imports from CLI/services/features).
* Used across the repo as the single source of truth for compatibility concerns.

#### 7) `_internal/` and `_internal/utils/` (private infrastructure)

**Role:** implementation details behind public shims; low-level infrastructure and dependency-safe utilities.

**Allowed:**

* General low-level helpers safe to import widely (`_internal/utils/*`).
* Internal implementations behind root shims (cache, precedence helpers, path helpers, etc.).

**Prohibited:**

* CLI presentation.
* Feature/business logic (unless it is truly infrastructure and not semantic policy).

**Import discipline:**

* Non-`_internal/` modules should use public shims where they exist rather than importing `_internal/*` directly.

#### 8) `common/` (curated cross-feature helpers)

**Role:** prevent dependency cycles when a helper is needed by two otherwise-independent layers.

**Key rule:** `common/` is not a “shared utilities” hub. It exists only when:

* A helper is used across multiple packages, and
* Placing it in either owning package would create an undesirable dependency direction or a cycle.

**dev-3 assessment:** `common/override_utils.py` is used by `cli/` and `dashboard/`. Keeping it in `common/` is structurally appropriate; the fact that `common/` currently contains only one module is a positive signal of curation, not a deficiency.

#### 9) Boundary package for external representations

**Taxonomy requirement:** external schema/payload transformations must be isolated to a **single, explicit boundary package** (e.g., `adapters/`).

**dev-3 status:** `schema_bindings/` exists but is empty. This is noncompliant with a clear boundary package strategy: either remove it until implemented or replace it with the authoritative boundary package when ready. The taxonomy requires **one** boundary location, not multiple placeholders.

### Taxonomy rules for repository-level directories (outside `src/`)

#### `schemas/`

* JSON Schema contracts for persisted artifacts.
* Not runtime Python code.

#### `typings/`

* Stub files for third-party libraries lacking adequate typing.
* Tooling support only.

#### `scripts/`

* Developer tooling and repository maintenance.
* Must not be imported by runtime package code.

#### `docs/`

* Documentation and ADRs.

#### `examples/`

* Example configs/plugins for demonstration and manual testing.

### Test taxonomy (`tests/`)

**Repository contract:** the test suite is a pyramid of suites with explicit intent.

Observed suites in dev-3:

```text
tests/
├── unit/
├── integration/
├── e2e/
├── property/
├── performance/
├── fixtures/
└── snapshots/
```

**Rules:**

1. **Unit tests must mirror product domains.** Prefer `tests/unit/<package>/...` matching `src/ratchetr/<package>/...`.
2. Shared builders/stubs belong in `tests/fixtures/`.
3. Golden files belong in a documented snapshot location (either `tests/snapshots/` or `tests/fixtures/snapshots/`), but not both without clear intent.

## Consequences

### Positive

* Clear, enforceable placement rules reduce structural drift and import cycles.
* Deliberate curation of shared code (`common/`) supports DRY without “utils sprawl.”
* Explicit boundary-package requirement prevents external-representation concerns from leaking into runtime layers.
* Tests become self-placing and easier to maintain as the repo grows.

### Negative / Tradeoffs

* Requires periodic refactors to keep modules in correct layers as features evolve.
* Curated sharing requires discipline and occasional “promote/demote” decisions.

## Codebase Compliance Review (dev-3)

The following items are **noncompliant with this taxonomy** and should be corrected. These are structural/taxonomy issues only.

1. **Unit test directories do not consistently mirror product domains**

   * Observed: `tests/unit/misc/`, `tests/unit/models/`, `tests/unit/utilities/` and `tests/unit/common/test_paths.py` testing non-`common` modules.
   * Impact: violates the “mirror product domains” principle; makes placement subjective and encourages future drift.
   * Correction: relocate tests to domain-aligned directories (or introduce a clearly-scoped `tests/unit/architecture/` for meta/guardrail tests and keep it minimal).

## Links

* `tests/README.md` (test suite intent and pyramid layout)
* Existing ADRs (policy, CLI semantics, engines) — separate scope from taxonomy ADRs
* Repository tree: `src/ratchetr/` (package taxonomy), `tests/` (suite taxonomy)

---
